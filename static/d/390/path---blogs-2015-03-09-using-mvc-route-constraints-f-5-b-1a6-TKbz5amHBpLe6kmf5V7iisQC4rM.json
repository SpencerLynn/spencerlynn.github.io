{"data":{"markdownRemark":{"html":"<p>A recent work project needed the ability to \"turn on and off\" MVC routes dynamically, depending on the user that was logged into the system. However, I didn't want to update all the existing controllers to handle the logic in each action. Furthermore, I didn't want any new controllers/actions to need to know about this logic.</p>\n<p>I did some research and tried a few strategies. Then <a href=\"http://joshuarogers.net\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Josh Rogers</a> mentioned <code class=\"language-text\">IRouteConstraint</code>.</p>\n<!-- more -->\n<p>The <code class=\"language-text\">IRouteConstraint</code> interface only has one method to implement: <code class=\"language-text\">Match</code>. We'll add a class to handle this constraint.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre style=\"counter-reset: linenumber 0\" class=\"language-c# line-numbers\"><code class=\"language-c#\">using System.Linq;\nusing System.Web;\nusing System.Web.Routing;\n\npublic class UserRouteConstraint : IRouteConstraint\n{\n    public bool Match(HttpContextBase httpContext, Route route, string parameterName, RouteValueDictionary values, RouteDirection routeDirection)\n    {\n        // We&#39;ll return true or false on whether this route is allowed\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>You'll notice that the arguments into <code class=\"language-text\">Match</code> make this function quite flexible. There is the HTTP context, the parameter name, a route value dictionary that holds various values, and the direction of the route<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>. All sorts of route constraints can be built with these combinations.</p>\n<p>For this use case, all we needed to do was check which user was logged in (via a cookie) and see if that user is allowed to visit the area that is being requested. Let's begin to build this method. For now, we will look past how  we determine which views are visible to which user. In my case they were stored in a database. So a quick database query was all that was needed.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre style=\"counter-reset: linenumber 0\" class=\"language-c# line-numbers\"><code class=\"language-c#\">using System.Linq;\nusing System.Web;\nusing System.Web.Routing;\n\npublic class UserRouteConstraint : IRouteConstraint\n{\n    public bool Match(HttpContextBase httpContext, Route route, string parameterName, RouteValueDictionary values, RouteDirection routeDirection)\n    {\n        var usernameCookie = httpContext.Request.Cookies[&quot;name&quot;];\n        if (usernameCookie == null)\n            return true;\n\n        return CanUserViewRoute(usernameCookie.Value);\n    }\n\n    private bool CanUserViewRoute(string username, Route route, RouteValueDictionary values)\n    {\n        var area = (string)route.DataTokens[&quot;area&quot;];\n        var controller = (string)values[&quot;controller&quot;];\n        var areaController = string.Format(&quot;{0}/{1}&quot;, area, controller);\n\n        // Look for any view that matches the area-controller combination\n        return GetViewsForUser(usernameCookie.Value).Any(v =&gt; v.Equals(areaController));\n    }\n\n    private IEnumerable&lt;string&gt; GetViewsForUser(string username)\n    {\n        // Whatever is needed to determine which views are visible to this user\n        return new List&lt;string&gt;();\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Obviously, this is far from robust. For example, default actions on controllers are not taken into consideration. It might also be a good idea to find a different way to compare the requested area/controller to the ones visible by the user. Also how those values are stored in the database - \"area\"/\"controller\" might be be the best way<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>.</p>\n<p>Our job is not done yet, however. For this route constraint to work, it has to be added to the route. I already mentioned that I did not want to update each controller. I also don't want to update each Area Registration to include the route constraints. However, I can just spin through all my routes once they are all registered.</p>\n<p>In my subclass of <code class=\"language-text\">HttpApplication</code>, in the <code class=\"language-text\">Application_Start</code> method, I will add this constraint to each route. The constraint will be added as a controller constraint.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre style=\"counter-reset: linenumber 0\" class=\"language-c# line-numbers\"><code class=\"language-c#\">using System.Web;\nusing System.Web.Http;\nusing System.Web.Mvc;\nusing System.Web.Routing;\n\npublic class MyApplication : HttpApplication\n{\n    protected void Application_Start()\n    {\n        // Other code to register areas\n\n        foreach (Route route in RouteTable.Routes)\n        {\n            if (route.Constraints == null)\n                route.Constraints = new RouteValueDictionary();\n\n            route.Constraints[&quot;controller&quot;] = new UserRouteConstraint();\n        }\n\n        // Other code to register all routes in each area\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Again, this code could probably be spruced up a bit and some robustness added. But for demonstration purposes, it does the job.</p>\n<p>For this use case, it worked perfectly. We were able to prevent certain users from accessing routes that were they were not permitted to view.</p>\n<p>There might be a better way to do this. If you know of a better way, feel free to comment and let me know!</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>I'm really good taking a parameter name and re-wording it into a sentence :)</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>This is just a blog post and demonstration after all. You can't expect me to do all the work for you. That's what StackOverflow is for..</p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","excerpt":"A recent work project needed the ability to \"turn on and off\" MVC routes dynamically, depending on the user that was logged into the system. However, I didn't want to update all the existing controllers to handle the logic in each action. Furthermore, I didn't want any new controllers/actions to need to know about this logic.\n\nI did some research and tried a few strategies. Then [Josh Rogers](http://joshuarogers.net) mentioned `IRouteConstraint`.\n\n","frontmatter":{"title":"Using MVC Route Constraints","date":"March 09, 2015"}}},"pageContext":{"slug":"/blogs/2015-03-09-using-mvc-route-constraints/"}}